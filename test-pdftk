#!/bin/sh -- # Really perl
eval 'exec perl $0 ${1+"$@"}'
if 0;


$home = $0;
$home =~ s?/([^/]+)$??;
$me = $1;

$ENV{'LD_LIBRARY_PATH'} = "$home/lib:$ENV{'LD_LIBRARY_PATH'}";

$pdftk = "$home/pdftk";


@mypdftk=($pdftk,"$home/example.pdf","cat", "2-3", "output","$home/out.pdf");
($return, $output)=&execlist(@mypdftk);
&execreport("  pdftk", join(" ",@mypdftk),$return,$output);
if($return >0) {die "\n\npdftk failed\n";}

open FH, "<", "$home/out.pdf"
        or die "\n\npdftk output not found\n";
        
local $/ = undef;  # slurp!

$checksum = length <FH>;

if($checksum != 7003) {die "\n\npdftk output file not correct\n";}

print "\n\n pdftk is working correctly\n";

unlink "$home/out.pdf";

sub execlist
  {
  local(@list)=@_;
  $childout="$$child.out";
  unless(fork)
    { #child
    open(STDOUT, ">$childout");
    open(STDERR, ">&STDOUT");
    exec(@list);
    }
  wait;
  open(CHILD, "<$childout");
  local(@readchild)=<CHILD>;
  close(CHILD);
  $output=join('',@readchild);
  $return = $?/256;
  ($return, $output);
  }


sub execisofax
  {
  local(@list)=@_;
  while(1)
    {
    print "executing $list[0]\n";
    ($return, $output)=&execlist(@list);
    if($list[0] =~ /splitfax/) {$return=0;}
    if($return==0 && $output =~ /All 'filters' licenses are in use/)
      {
      $return=4;
      }
    $prefix=$list[1];$prefix=~s/.+\///;$prefix="  ".$prefix;
    &execreport($prefix, join(' ',@list), "$return -> $IsoReturn[$return] -> $IsoReturnDo[$return]", $output);
    if($IsoReturnDo[$return] ne 'Retry') { last;}
    sleep 20;
    };
  if($IsoReturnDo[$return] eq 'Fatal')
    {
    $error="$error\n Command failed [join(@list)] see log for details" ;
    }
  ($return, $output);
  }

sub execreport
  {
  local($prefix, $command, $return, $output) = @_;

  $output =~ s/\n$//;
  $output =~ s/\n/\n$prefix: /g;
  $output = "$output\n";
  
  print "$me: Executing [$command]\n";
  print "$prefix: Returned [$return]\n";
  print "$prefix: Output [\n$prefix: $output$prefix: ]\n";
  }

sub findfiles
  {
  local($dir,$suffix)=@_;
  local @firstlist;
  local @secondlist;
  
  opendir(INBOX, $dir);
  @firstlist = grep(/$suffix$/, readdir(INBOX));
  closedir(INBOX);
  foreach $file (@firstlist)
    {
    next if($file eq "." || $file eq "..");
    push @secondlist, "$dir/$file";
    }
  return @secondlist;
  }

sub  oldestfirst
  {
  local @firstlist=@_;
  local @age;
  local @secondlist;
  
  #set the cutoff time, files newer than this won't be processed
  $cutoff=time-$props{'delay'};
  
  foreach $file (@firstlist)
    {
    #process individual files
    #check if last modified time is older than delay
    $lastmod=$^T - (-M "$file")*3600*24;
    #&writetrace("testing $file last $lastmod cutoff is $cutoff"); 
    if($lastmod < $cutoff)
      {
      $age{$file}=$lastmod;
      }
    }
  #oldest first
  @secondlist = sort { $age{$a} <=> $age{$b} } keys %age;
  return @secondlist;
  }
